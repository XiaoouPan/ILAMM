% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cvNcvxHuberReg}
\alias{cvNcvxHuberReg}
\title{K-fold cross validation for non-convex regularized Huber regression}
\usage{
cvNcvxHuberReg(X, Y, lSeq = NULL, nlambda = 30L, penalty = "SCAD",
  tSeq = NULL, ntau = 5L, phi0 = 0.001, gamma = 1.5,
  epsilon_c = 1e-04, epsilon_t = 1e-04, iteMax = 500L, nfolds = 3L,
  intercept = FALSE, itcpIncluded = FALSE)
}
\arguments{
\item{X}{An \eqn{n} by \eqn{d} design matrix with each row being a sample and each column being a variable, either low-dimensional data (\eqn{d \le n}) or high-dimensional data (\eqn{d > n}) are allowed.}

\item{Y}{A continuous response vector with length \eqn{n}.}

\item{lSeq}{Sequence of tuning parameter of regularized regression \eqn{\lambda}, every element should be positive. If it's not specified, the default sequence is generated in this way: define \eqn{\lambda_max = max(|Y^T X|) / n}, and \eqn{\lambda_min = 0.01 * \lambda_max}, then \code{lseq} is a sequence from \eqn{\lambda_max} to \eqn{\lambda_min} that decreases uniformly on log scale.}

\item{nlambda}{Number of \eqn{\lambda} to generate the default sequence \code{lSeq}. It's not necessary if \code{lSeq} is specified. The default value is 30.}

\item{penalty}{Type of non-convex penalties with default setting "SCAD", possible choices are: "Lasso", "SCAD" and "MCP".}

\item{tSeq}{Sequence of robustness parameter of Huber loss \eqn{\tau}, every element should be positive. If it's not specified, the default sequence is generated in this way: define \eqn{R} as the residual from Lasso by fitting \code{cvNcvxReg} with \code{lSeq}, and \eqn{\sigma_MAD = median(|R - median(R)|) / \Phi^(-1)(3/4)} is the median absolute deviation estimator, then \code{tSeq} = \eqn{2^j * \sigma_MAD \sqrt(n / log(nd))}, where \eqn{j} are integers from -\code{ntau}/2 to \code{ntau}/2.}

\item{ntau}{Number of \eqn{\tau} to generate the default sequence \code{tSeq}. It's not necessary if \code{tSeq} is specified. The default value is 5.}

\item{phi0}{The initial value of the isotropic parameter \eqn{\phi} in I-LAMM algorithm. The defalut value is 0.001.}

\item{gamma}{The inflation parameter in I-LAMM algorithm, in each iteration of I-LAMM, we will inflate \eqn{\phi} by \eqn{\gamma}. The defalut value is 1.5.}

\item{epsilon_c}{The tolerance level for contraction stage, iteration of contraction will stop when \eqn{||\beta_new - \beta_old||_2 / \sqrt(d + 1) < \epsilon_c}. The defalut value is 1e-4.}

\item{epsilon_t}{The tolerance level for tightening stage, iteration of tightening will stop when \eqn{||\beta_new - \beta_old||_2 / \sqrt(d + 1) < \epsilon_t}. The defalut value is 1e-4.}

\item{iteMax}{The maximal number of iteration in either contraction or tightening stage, if this number is reached, the convergence of I-LAMM is failed. The defalut value is 500.}

\item{nfolds}{The number of folds to conduct cross validation, values that are greater than 10 are not recommended, and it'll be modified to 10 if the input is greater than 10. The default value is 3.}

\item{intercept}{Boolean value indicating whether an intercept term should be included into the model. The default setting is \code{FALSE}.}

\item{itcpIncluded}{Boolean value indicating whether a column of 1's has been included in the design matrix \eqn{X}. The default setting is \code{FALSE}.}
}
\value{
A list including the following terms will be returned:
\itemize{
\item \code{beta} The estimated \eqn{\beta} with \eqn{\lambda} and \eqn{\tau} determined by cross validation, it's a vector with length d + 1, with the first one being the value of intercept (0 if \code{intercept = FALSE}).
\item \code{penalty} The type of penalty.
\item \code{lambdaSeq} The sequence of \eqn{\lambda}'s for cross validation.
\item \code{tauSeq} The sequence of \eqn{\tau}'s for cross validation.
\item \code{mse} The mean squared error from cross validation, it's a matrix with dimension \code{nlambda} by \code{ntau}.
\item \code{lambdaMin} The value of \eqn{\lambda} in \code{lSeq} that minimized \code{mse}.
\item \code{tauMin} The value of \eqn{\tau} in \code{tSeq} that minimized \code{mse}.
\item \code{nfolds} The number of folds for cross validation.
}
}
\description{
The function performs k-fold cross validation for (high-dimensional) Huber regularized regression with non-convex penalties: Lasso, SCAD and MCP, and it's implemented by I-LAMM algorithm.
}
\details{
The design matrix \eqn{X} can be either high-dimensional or low-dimensional, its number of rows should be the same as the length of \eqn{Y}. The sequence of \eqn{\lambda}'s and \eqn{\tau}'s have default settings but they can be user-specified. All the arguments except for \eqn{X} and \eqn{Y} have default settings.
}
\examples{
n = 50
d = 100
set.seed(2018)
X = matrix(rnorm(n * d), n, d)
beta = c(rep(2, 3), rep(0, d - 3))
Y = X \%*\% beta + rlnorm(n, 0, 1.2) - exp(1.2^2 / 2)
# Fit SCAD without intercept, with lambda and tau determined by 3-folds cross validation
fit = cvNcvxHuberReg(X, Y)
fit$beta
fit$lambdaMin
fit$tauMin
# Fit MCP with intercept, with lambda and tau determined by 3-folds cross validation
fit = cvNcvxHuberReg(X, Y, penalty = "MCP", intercept = TRUE)
fit$beta
fit$lambdaMin
fit$tauMin
}
\references{
Fan, J., Liu, H., Sun, Q. and Zhang, T. (2018). I-LAMM for sparse learning: Simultaneous control of algorithmic complexity and statistical error. Ann. Statist. 46 814â€“841.
}
\seealso{
\code{\link{ncvxHuberReg}}
}
\author{
Xiaoou Pan, Qiang Sun, Wen-Xin Zhou
}
